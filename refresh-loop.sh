#!/bin/sh
set -eu

LOG_FILE="$LOG_DIR/refresh.log"
PIA_LOG="$LOG_DIR/pia-wg-config.log"
DOCKER_LOG="$LOG_DIR/docker.log"
: "${PIA_WG_CONFIG_BIN:=/usr/local/bin/pia-wg-config}"
: "${PIA_WG_CONFIG_URL:=}"
: "${PIA_WG_CONFIG_SHA256:=}"
: "${SELF_TEST:=0}"

# ANSI color codes
COLOR_RESET="\033[0m"
COLOR_CYAN="\033[36m"
COLOR_GREEN="\033[32m"
COLOR_YELLOW="\033[33m"
COLOR_RED="\033[31m"

log_level() {
  case "$LOG_LEVEL" in
    debug) echo 0 ;;
    info) echo 1 ;;
    warn) echo 2 ;;
    error) echo 3 ;;
    *) echo 1 ;;
  esac
}

log_should_write() {
  level="$1"
  current=$(log_level)
  case "$level" in
    debug) level_num=0 ;;
    info) level_num=1 ;;
    warn) level_num=2 ;;
    error) level_num=3 ;;
    *) level_num=1 ;;
  esac
  [ "$level_num" -ge "$current" ]
}

log_color() {
  level="$1"
  case "$level" in
    debug) echo "$COLOR_CYAN" ;;
    info) echo "$COLOR_GREEN" ;;
    warn) echo "$COLOR_YELLOW" ;;
    error) echo "$COLOR_RED" ;;
    *) echo "" ;;
  esac
}

log() {
  level="$1"
  shift
  if log_should_write "$level"; then
    ts=$(date -u "+%Y-%m-%dT%H:%M:%SZ")
    msg="$*"
    color=$(log_color "$level")
    # Colored output to stdout (for docker logs)
    printf "%s %b[%s]%b %s\n" "$ts" "$color" "$level" "$COLOR_RESET" "$msg"
    # Plain text to log file
    echo "$ts [$level] $msg" >> "$LOG_FILE"
  fi
}

download_pia_wg_config() {
  if [ -z "$PIA_WG_CONFIG_URL" ]; then
    return 0
  fi

  log info "Downloading pia-wg-config from $PIA_WG_CONFIG_URL"
  tmp="/tmp/pia-wg-config.download"
  rm -f "$tmp"

  case "$PIA_WG_CONFIG_URL" in
    file://*)
      src="${PIA_WG_CONFIG_URL#file://}"
      if ! cp "$src" "$tmp"; then
        log warn "Failed to copy pia-wg-config from $PIA_WG_CONFIG_URL"
        rm -f "$tmp"
        return 1
      fi
      ;;
    *)
      if ! wget -qO "$tmp" "$PIA_WG_CONFIG_URL"; then
        log warn "Failed to download pia-wg-config"
        rm -f "$tmp"
        return 1
      fi
      ;;
  esac

  if [ -n "$PIA_WG_CONFIG_SHA256" ]; then
    if ! echo "$PIA_WG_CONFIG_SHA256  $tmp" | sha256sum -c - >/dev/null 2>&1; then
      log warn "pia-wg-config checksum verification failed"
      rm -f "$tmp"
      return 1
    fi
  fi

  mv "$tmp" "$PIA_WG_CONFIG_BIN"
  chmod +x "$PIA_WG_CONFIG_BIN"
  log info "pia-wg-config updated at $PIA_WG_CONFIG_BIN"
  return 0
}

backup_config() {
  if [ -f "$WG_CONF_PATH" ]; then
    ts=$(date -u "+%Y%m%d%H%M%S")
    cp -p "$WG_CONF_PATH" "$WG_CONF_PATH.bak-$ts"
    log info "Backed up existing config to $WG_CONF_PATH.bak-$ts"
  else
    log info "No existing config found, creating new"
  fi
}

validate_config() {
  path="$1"
  if [ ! -s "$path" ]; then
    log error "Generated config is empty or missing: $path"
    return 1
  fi
  if ! grep -q "^\[Interface\]" "$path"; then
    log error "Generated config missing [Interface] section"
    return 1
  fi
  if ! grep -q "^\[Peer\]" "$path"; then
    log error "Generated config missing [Peer] section"
    return 1
  fi
  return 0
}

restore_backup() {
  latest_backup=$(ls -1t "$WG_CONF_PATH".bak-* 2>/dev/null | head -n 1 || true)
  if [ -n "$latest_backup" ]; then
    cp -p "$latest_backup" "$WG_CONF_PATH"
    log warn "Restored config from $latest_backup"
  fi
}

generate_config() {
  log info "Generating new WireGuard config via pia-wg-config"

  backup_config

  # Build pia-wg-config command with optional port forwarding flag
  pf_flag=""
  if [ "$PIA_PORT_FORWARDING" = "true" ]; then
    pf_flag="-p"
  fi
  "$PIA_WG_CONFIG_BIN" -s $pf_flag -r "$PIA_REGION" -o "$WG_CONF_PATH" "$PIA_USERNAME" "$PIA_PASSWORD" >>"$PIA_LOG" 2>&1

  if ! validate_config "$WG_CONF_PATH"; then
    restore_backup
    return 1
  fi

  # Extract the server name if present
  server_name=$(grep "^ServerCommonName" "$WG_CONF_PATH" 2>/dev/null | cut -d= -f2 | tr -d ' ' || true)
  if [ -n "$server_name" ]; then
    log info "Connected to server: $server_name"
  fi

  # Add header comment with metadata
  ts=$(date -u "+%Y-%m-%dT%H:%M:%SZ")
  {
    echo "# Generated by pia-wg-refresh"
    echo "# Date: $ts"
    echo "# Region: $PIA_REGION"
    if [ -n "$server_name" ]; then
      echo "# Server: $server_name (use this for SERVER_NAMES if port forwarding)"
    fi
    echo ""
    cat "$WG_CONF_PATH"
    echo ""
  } > "$WG_CONF_PATH.tmp"
  mv "$WG_CONF_PATH.tmp" "$WG_CONF_PATH"

  log info "Replaced config at $WG_CONF_PATH"
  return 0
}

# Exit codes: 0 = success, 1 = failure
check_connectivity() {
  # First check if container is stuck in a restart loop using docker inspect
  # This is more reliable than parsing stderr from docker exec
  if [ "$(docker inspect "$GLUETUN_CONTAINER" --format '{{.State.Restarting}}' 2>/dev/null)" = "true" ]; then
    log debug "Container $GLUETUN_CONTAINER is in restart loop (detected via docker inspect)"
    return 1
  fi

  # Use wget with 10 second timeout to avoid hanging on DNS issues
  if docker exec "$GLUETUN_CONTAINER" wget -T 10 -qO- "$CHECK_URL" >/dev/null 2>&1; then
    return 0
  fi

  return 1
}

restart_gluetun() {
  log warn "Restarting container $GLUETUN_CONTAINER"
  docker restart "$GLUETUN_CONTAINER" >>"$DOCKER_LOG" 2>&1 || true
}

download_pia_wg_config || true

if [ ! -x "$PIA_WG_CONFIG_BIN" ]; then
  log error "pia-wg-config not found or not executable at $PIA_WG_CONFIG_BIN"
  exit 1
fi

if [ "$SELF_TEST" = "1" ]; then
  log info "Self-test mode enabled; exiting after startup checks"
  exit 0
fi

failure_count=0
generation_failures=0
success_count=0
tunnel_confirmed=0
first_check=1

log info "Starting refresh loop (interval=${CHECK_INTERVAL_SECONDS}s, healthy_interval=${HEALTHY_CHECK_INTERVAL_SECONDS}s, threshold=$FAIL_THRESHOLD, max_retries=$MAX_GENERATION_RETRIES)"

while true; do
  if [ "$first_check" -eq 1 ]; then
    log info "Waiting for tunnel..."
    first_check=0
  fi

  log debug "Running connectivity check..."
  if check_connectivity; then
    # First success after startup or recovery
    if [ "$tunnel_confirmed" -eq 0 ]; then
      log info "Tunnel up"
      tunnel_confirmed=1
    elif [ "$failure_count" -ne 0 ]; then
      log info "Connectivity restored"
    fi

    failure_count=0
    generation_failures=0
    success_count=$((success_count + 1))

    log debug "Connectivity check passed ($success_count)"

    # Periodic health log at info level
    if [ "$((success_count % HEALTH_LOG_INTERVAL))" -eq 0 ]; then
      log info "Tunnel healthy (${success_count} consecutive checks)"
    fi

    # Use longer interval when healthy
    sleep "$HEALTHY_CHECK_INTERVAL_SECONDS"
  else
    failure_count=$((failure_count + 1))
    success_count=0
    tunnel_confirmed=0

    if [ "$failure_count" -ge "$FAIL_THRESHOLD" ]; then
      log warn "Connectivity check failed ($failure_count/$FAIL_THRESHOLD)"
    else
      log debug "Connectivity check failed ($failure_count/$FAIL_THRESHOLD)"
    fi

    if [ "$failure_count" -ge "$FAIL_THRESHOLD" ]; then
      if [ "$generation_failures" -ge "$MAX_GENERATION_RETRIES" ]; then
        log error "Max generation retries ($MAX_GENERATION_RETRIES) reached, waiting for connectivity to recover"
      elif generate_config; then
        restart_gluetun
        failure_count=0
        generation_failures=0
      else
        generation_failures=$((generation_failures + 1))
        log error "Config generation failed ($generation_failures/$MAX_GENERATION_RETRIES)"
        failure_count=0
      fi
    fi

    # Use shorter interval when degraded
    sleep "$CHECK_INTERVAL_SECONDS"
  fi
done
